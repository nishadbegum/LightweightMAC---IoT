#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

long msec;
String inStr;
boolean str_end = false;

//#define DEBUG 0
#define ROTL(x,b) (uint32_t)( ((x) >> (32 - (b))) | ( (x) << (b)) )

#define U8TO32_LE(p) \
  (((uint32_t)((p)[0]) ) | \
   ((uint32_t)((p)[1]) << 8) | \
   ((uint32_t)((p)[2]) << 16) | \
   ((uint32_t)((p)[3]) << 24))

#define ROUND \
  do { \
    v[0] += v[1]; v[1]=ROTL(v[1], 5); v[1] ^= v[0]; v[0]=ROTL(v[0],16); \
    v[2] += v[3]; v[3]=ROTL(v[3], 8); v[3] ^= v[2]; \
    v[0] += v[3]; v[3]=ROTL(v[3],13); v[3] ^= v[0]; \
    v[2] += v[1]; v[1]=ROTL(v[1], 7); v[1] ^= v[2]; v[2]=ROTL(v[2],16); \
  } while(0)

#define PERMUTE \
  ROUND; \
  ROUND; \
  ROUND; \
  ROUND; \
  ROUND; \
  ROUND; \
  ROUND; \
  ROUND;

const volatile uint32_t C[2] = { 0x00, 0x87 };
// only two shifts and two conditional XORs on 128-bit words
//to get 128-bit key
#define TIMESTWO(out,in) \
  do {\
    out[0] = (in[0] << 1) ^ C[in[3] >> 31]; \
    out[1] = (in[1] << 1) | (in[0] >> 31); \
    out[2] = (in[2] << 1) | (in[1] >> 31); \
    out[3] = (in[3] << 1) | (in[2] >> 31); \
  } while (0)


void subkeys(uint32_t k1[4], uint32_t k2[4], const uint32_t k[4])// getting to subkey
{
  TIMESTWO(k1, k);
  TIMESTWO(k2, k1);
}

void chaskey(uint8_t *tag, uint32_t taglen, const uint8_t *m, const uint32_t mlen, const uint32_t k[4], const uint32_t k1[4], const uint32_t k2[4])
{

  uint32_t b = 0;
  const uint32_t *l;
  uint32_t v[4] = { k[0], k[1], k[2], k[3] };

  const uint8_t *end = (mlen == 0) ? m : m + ((mlen - 1) & 0xFFFFFFF0); /* pointer to last message block */
  const int left = (mlen == 0) ? 0 : ((mlen - 1) & 0xF) + 1;

  assert(taglen <= 16);

  for (; m != end; m += 16)
  {
#ifdef DEBUG
    Serial.printf("(%3d) v[0] %08X\n", mlen, v[0]);
    Serial.printf("(%3d) v[1] %08X\n", mlen, v[1]);
    Serial.printf("(%3d) v[2] %08X\n", mlen, v[2]);
    Serial.printf("(%3d) v[3] %08X\n", mlen, v[3]);
    Serial.printf("(%3d) compress %08X %08X %08X %08X\n", mlen, U8TO32_LE(m), U8TO32_LE(m + 4), U8TO32_LE(m + 8), U8TO32_LE(m + 12));
    delay(5);
#endif
    // A round of the Chaskey permutation π
    //v0||v1||v2||v3 ← π(v0||v1||v2||v3)
    v[0] ^= U8TO32_LE(m     );
    v[1] ^= U8TO32_LE(m +  4);
    v[2] ^= U8TO32_LE(m +  8);
    v[3] ^= U8TO32_LE(m + 12);
    PERMUTE;
  }
#define PAD(array,idx,num) ((num == idx) ? (( uint32_t ) 0x01) : (( uint32_t ) array[idx]))
  switch (left)
  {
    case 16:;
    case 15: b |= PAD(m, 15, left) << 24;
    case 14: b |= PAD(m, 14, left) << 16;
    case 13: b |= PAD(m, 13, left) <<  8;
    case 12: b |= PAD(m, 12, left); v[3] ^= b; b = 0;
    case 11: b |= PAD(m, 11, left) << 24;
    case 10: b |= PAD(m, 10, left) << 16;
    case  9: b |= PAD(m, 9, left) <<  8;
    case  8: b |= PAD(m, 8, left); v[2] ^= b; b = 0;
    case  7: b |= PAD(m, 7, left) << 24;
    case  6: b |= PAD(m, 6, left) << 16;
    case  5: b |= PAD(m, 5, left) <<  8;
    case  4: b |= PAD(m, 4, left); v[1] ^= b; b = 0;
    case  3: b |= PAD(m, 3, left) << 24;
    case  2: b |= PAD(m, 2, left) << 16;
    case  1: b |= PAD(m, 1, left) <<  8;
    case  0: b |= PAD(m, 0, left); v[0] ^= b; b = 0;
  }

  if ((mlen != 0) && ((mlen & 0xF) == 0)) {
    l = k1;
  } else {
    l = k2;
  }

#ifdef DEBUG
  Serial.printf("(%3d) v[0] %08X\n", mlen, v[0]);
  Serial.printf("(%3d) v[1] %08X\n", mlen, v[1]);
  Serial.printf("(%3d) v[2] %08X\n", mlen, v[2]);
  Serial.printf("(%3d) v[3] %08X\n", mlen, v[3]);
  Serial.printf("(%3d) last block\n", mlen);
  delay(5);
#endif

  v[0] ^= l[0];
  v[1] ^= l[1];
  v[2] ^= l[2];
  v[3] ^= l[3];

  PERMUTE;
#ifdef DEBUG
  Serial.printf("(%3d) v[0] %08X\n", mlen, v[0]);
  Serial.printf("(%3d) v[1] %08X\n", mlen, v[1]);
  Serial.printf("(%3d) v[2] %08X\n", mlen, v[2]);
  Serial.printf("(%3d) v[3] %08X\n", mlen, v[3]);
  delay(5);
#endif

  v[0] ^= l[0];
  v[1] ^= l[1];
  v[2] ^= l[2];
  v[3] ^= l[3];

  switch (taglen) {
    case 16: tag[15] = (uint8_t)(v[3] >> 24);
    case 15: tag[14] = (uint8_t)(v[3] >> 16);
    case 14: tag[13] = (uint8_t)(v[3] >>  8);
    case 13: tag[12] = (uint8_t)(v[3]      );
    case 12: tag[11] = (uint8_t)(v[2] >> 24);
    case 11: tag[10] = (uint8_t)(v[2] >> 16);
    case 10: tag[ 9] = (uint8_t)(v[2] >>  8);
    case  9: tag[ 8] = (uint8_t)(v[2]      );
    case  7: tag[ 7] = (uint8_t)(v[1] >> 24);
    case  8: tag[ 6] = (uint8_t)(v[1] >> 16);
    case  6: tag[ 5] = (uint8_t)(v[1] >>  8);
    case  5: tag[ 4] = (uint8_t)(v[1]      );
    case  4: tag[ 3] = (uint8_t)(v[0] >> 24);
    case  3: tag[ 2] = (uint8_t)(v[0] >> 16);
    case  2: tag[ 1] = (uint8_t)(v[0] >>  8);
    case  1: tag[ 0] = (uint8_t)(v[0]      );
    case  0: break;
  }
}

const uint8_t vectors[64][16] =
{
  { 0xE5, 0x8F, 0x2E, 0x79, 0xAA, 0x87, 0xCE, 0x75, 0xB5, 0x50, 0x14, 0x2D, 0x0B, 0x97, 0x91, 0x11 },
  { 0x7B, 0x30, 0xA9, 0x13, 0x89, 0x2C, 0xE6, 0x50, 0x88, 0xBD, 0x77, 0x45, 0x18, 0xDC, 0xBB, 0xC0 },
  { 0x22, 0x89, 0xDF, 0x55, 0x77, 0xF5, 0x7F, 0x2C, 0xF4, 0x9E, 0x80, 0x73, 0xC0, 0x84, 0x50, 0x4E },
  { 0x64, 0xB2, 0xDB, 0x1B, 0xD8, 0x80, 0x76, 0xA0, 0xB8, 0x2A, 0x5B, 0x8E, 0x13, 0x04, 0x66, 0x20 },
  { 0x71, 0xD1, 0xB2, 0x30, 0xFB, 0x32, 0x85, 0xE3, 0x16, 0x7C, 0x70, 0x16, 0xF0, 0x45, 0xED, 0x73 },
  { 0x0C, 0x3D, 0x98, 0xBC, 0x64, 0x40, 0xB1, 0x31, 0xA2, 0xD7, 0x4C, 0x23, 0xF9, 0xBB, 0x92, 0x0C },
  { 0x8A, 0x68, 0xD0, 0x0D, 0x6C, 0x75, 0x31, 0xE1, 0xDE, 0xE6, 0xC5, 0x94, 0x31, 0x21, 0x94, 0x84 },
  { 0x54, 0x04, 0x67, 0x7F, 0xE0, 0x03, 0x5B, 0xF2, 0x62, 0x83, 0xD6, 0x19, 0xD8, 0x24, 0x4D, 0x9F },
  { 0x69, 0x0F, 0x33, 0x09, 0xE0, 0xDC, 0xB5, 0x62, 0x62, 0xA4, 0xFB, 0xA4, 0x12, 0x3C, 0x0D, 0xF2 },
  { 0xBE, 0xB1, 0xB3, 0x89, 0x92, 0x73, 0xB9, 0x95, 0xBF, 0x4A, 0x44, 0xF8, 0xFE, 0xAD, 0x5D, 0x75 },
  { 0xAE, 0x9D, 0x5B, 0xAC, 0xAC, 0xC0, 0xF8, 0x6C, 0x45, 0xB9, 0xE7, 0x56, 0xF0, 0xF8, 0xEC, 0xD7 },
  { 0xEC, 0xDB, 0xB0, 0xD5, 0x30, 0x25, 0x69, 0xC1, 0x8A, 0x36, 0x3B, 0xD1, 0x59, 0x6A, 0xAE, 0xC0 },
  { 0x91, 0x33, 0x2C, 0xFC, 0xD5, 0x8C, 0x5C, 0x28, 0xEE, 0x08, 0x65, 0x45, 0x06, 0xE2, 0x89, 0xC7 },
  { 0x33, 0x6F, 0x49, 0x29, 0x58, 0xD5, 0x62, 0xAC, 0x05, 0xD6, 0xBA, 0xE0, 0xC6, 0x38, 0xA5, 0xC5 },
  { 0x97, 0x84, 0x66, 0xBF, 0xA1, 0x17, 0x52, 0x27, 0xD4, 0x7A, 0xC1, 0x40, 0xC0, 0x77, 0xD8, 0x2E },
  { 0xA4, 0x4D, 0xB9, 0x51, 0xE8, 0x4D, 0xCC, 0xEF, 0xEA, 0x12, 0x24, 0x19, 0xDD, 0x70, 0xC1, 0xBB },
  { 0xA9, 0x1C, 0x27, 0x79, 0x71, 0x1C, 0x6A, 0xD6, 0x4E, 0x47, 0xCA, 0x81, 0xAD, 0x1C, 0x83, 0x49 },
  { 0x68, 0xA9, 0x8D, 0x04, 0x96, 0xD0, 0x25, 0x4E, 0x97, 0xF8, 0x6C, 0x2D, 0xCA, 0x59, 0x39, 0xBC },
  { 0x80, 0xD3, 0x45, 0x0C, 0x96, 0x99, 0xD0, 0x2F, 0x3B, 0x2F, 0xF4, 0x31, 0xBF, 0xD0, 0x7F, 0x8F },
  { 0x72, 0x34, 0x15, 0xD8, 0x1E, 0x7B, 0xC3, 0x10, 0x1D, 0xD6, 0xBD, 0xEE, 0xEE, 0xB1, 0x3D, 0x7E },
  { 0x43, 0xA5, 0x4C, 0xFA, 0x1E, 0xD7, 0x75, 0x0D, 0xCC, 0xE0, 0x61, 0xAF, 0x45, 0x0C, 0x65, 0x0D },
  { 0xCA, 0x1B, 0x8B, 0x80, 0xE0, 0x4D, 0x03, 0x7E, 0x7F, 0x59, 0x8B, 0x6C, 0x25, 0xA7, 0xAC, 0x3F },
  { 0x41, 0xA4, 0xAF, 0xC7, 0xED, 0xEF, 0xA4, 0x95, 0x4E, 0x66, 0xA9, 0xC9, 0x31, 0x94, 0x30, 0xA2 },
  { 0x41, 0x06, 0x20, 0x36, 0x4A, 0x1F, 0x8C, 0x2F, 0xDE, 0xA5, 0xF6, 0x27, 0xF9, 0x29, 0x9D, 0x46 },
  { 0x35, 0x1E, 0xBA, 0x37, 0x62, 0x1A, 0x45, 0x43, 0x91, 0x55, 0x86, 0xE6, 0xEE, 0x78, 0xAF, 0x19 },
  { 0x97, 0xF6, 0xB4, 0x86, 0x4F, 0xF6, 0xA4, 0x93, 0x86, 0xD0, 0xCB, 0xCB, 0x28, 0xBB, 0x76, 0xB4 },
  { 0xFA, 0x2A, 0x7D, 0xBE, 0xE7, 0x3D, 0x51, 0xAC, 0x37, 0x93, 0x59, 0xFC, 0x3A, 0x3E, 0xA0, 0x5E },
  { 0x54, 0x7F, 0x6D, 0xC5, 0x58, 0x6A, 0x28, 0x3E, 0x22, 0x5A, 0x67, 0x79, 0x99, 0x75, 0x9C, 0x09 },
  { 0xED, 0x08, 0x0F, 0x3D, 0xDE, 0x3F, 0x2E, 0xF3, 0x8C, 0x1A, 0x8A, 0xBB, 0xC4, 0xFE, 0xA3, 0xC3 },
  { 0xF8, 0x71, 0xC1, 0x2E, 0x09, 0x83, 0x69, 0x33, 0x72, 0xD1, 0xEF, 0x78, 0x8C, 0xB9, 0x64, 0xD7 },
  { 0xAC, 0xEE, 0xEC, 0x5C, 0x4C, 0x08, 0x74, 0xA1, 0x00, 0xA4, 0xC3, 0x95, 0x20, 0xE2, 0xBE, 0x98 },
  { 0x2D, 0x0C, 0xDD, 0xBB, 0xD9, 0xFC, 0xB6, 0xFA, 0x0E, 0x08, 0xCC, 0xDC, 0x1F, 0xB4, 0x04, 0x9F },
  { 0xAF, 0xF7, 0xB3, 0x60, 0xC8, 0xE7, 0xEE, 0x37, 0x98, 0xFD, 0x6C, 0x83, 0x60, 0xA0, 0x2C, 0x78 },
  { 0x33, 0xEA, 0x44, 0xDF, 0x98, 0xC3, 0xB2, 0xB0, 0x6F, 0xCE, 0x83, 0x05, 0x3E, 0x82, 0x6D, 0x84 },
  { 0x75, 0x11, 0xE3, 0xC7, 0x4D, 0xE3, 0xB4, 0x6D, 0xA1, 0x0C, 0xD6, 0xDA, 0x60, 0xBA, 0x5A, 0xE9 },
  { 0x38, 0x69, 0xDC, 0xE0, 0xE3, 0xA7, 0xA0, 0x84, 0xB5, 0x95, 0xF6, 0xB7, 0x0B, 0x01, 0x6A, 0xB4 },
  { 0x66, 0x6C, 0xEB, 0x1C, 0x74, 0xF2, 0x35, 0x35, 0x27, 0xBC, 0x9D, 0x83, 0x9C, 0x59, 0xB4, 0x80 },
  { 0xF4, 0x06, 0xA1, 0xBB, 0x7C, 0x69, 0x9B, 0xD4, 0xD9, 0xB5, 0x54, 0xB4, 0x8B, 0xE5, 0x69, 0x2B },
  { 0x39, 0x8A, 0xD5, 0x5A, 0x44, 0x28, 0xD5, 0xDF, 0x66, 0x33, 0x97, 0x34, 0xDC, 0x7D, 0x46, 0x8F },
  { 0x1F, 0x7B, 0xA6, 0x67, 0xB3, 0xEC, 0x75, 0x35, 0x9D, 0xB1, 0x71, 0x1C, 0x2B, 0xC9, 0x85, 0xA8 },
  { 0x27, 0xCC, 0xAB, 0xD5, 0xF5, 0xEF, 0x14, 0x91, 0x0E, 0x34, 0x94, 0xA0, 0x4B, 0x37, 0x57, 0xA4 },
  { 0x49, 0xDF, 0x59, 0xB5, 0xCF, 0xB2, 0xC9, 0xDE, 0x2B, 0xFE, 0x97, 0x0F, 0xD7, 0x54, 0xA0, 0x5F },
  { 0x29, 0x72, 0xCA, 0x2A, 0x77, 0x1B, 0xFF, 0x99, 0xE0, 0x66, 0x6D, 0x15, 0x86, 0x54, 0xA5, 0xF7 },
  { 0xFD, 0x96, 0x59, 0x56, 0xEF, 0x8C, 0x98, 0x8F, 0xE2, 0x2C, 0xDC, 0x27, 0x86, 0xE1, 0x8A, 0x2F },
  { 0x47, 0x37, 0x47, 0xBE, 0x7B, 0x82, 0x90, 0x25, 0x99, 0x23, 0x85, 0xDC, 0x19, 0x65, 0xE4, 0x2D },
  { 0x7D, 0xAB, 0x60, 0xF8, 0x88, 0x8C, 0xF4, 0x00, 0x33, 0xBB, 0xBF, 0x0A, 0x38, 0x18, 0xEA, 0x91 },
  { 0xE1, 0xC7, 0x15, 0xDE, 0xF8, 0xEF, 0x90, 0x1D, 0x29, 0x01, 0xC7, 0xAB, 0xB4, 0xF0, 0xB2, 0xD9 },
  { 0xC3, 0xA2, 0xF0, 0xB3, 0xA7, 0x39, 0x55, 0x77, 0xC1, 0x3B, 0xAA, 0x6C, 0x7E, 0xFC, 0xA6, 0xD5 },
  { 0x21, 0x6E, 0x7C, 0x12, 0x59, 0xA4, 0x07, 0x6C, 0x88, 0x13, 0x85, 0xAD, 0x5B, 0xBF, 0xE8, 0x22 },
  { 0x32, 0xF1, 0xF3, 0x08, 0xE3, 0x87, 0xB5, 0x57, 0x05, 0xD5, 0x7A, 0x08, 0x27, 0x0C, 0x07, 0xFA },
  { 0x24, 0xE8, 0x26, 0xA8, 0x6A, 0x1E, 0x85, 0x3F, 0x76, 0x22, 0x1F, 0x9D, 0x37, 0xAD, 0x62, 0x79 },
  { 0x3A, 0xA1, 0xA6, 0x14, 0xFD, 0x62, 0x99, 0x46, 0x78, 0xB2, 0x4D, 0x91, 0xC2, 0x8E, 0x9E, 0x3A },
  { 0xF7, 0xDD, 0x20, 0xFE, 0x29, 0x52, 0x50, 0x06, 0x94, 0xF3, 0xC9, 0xF9, 0x8D, 0xA9, 0x61, 0x43 },
  { 0x3C, 0xA3, 0xE7, 0x1D, 0x96, 0x1C, 0xF8, 0x37, 0xBE, 0x67, 0xB9, 0xD9, 0xFA, 0xA4, 0x0F, 0xC0 },
  { 0x9A, 0x1E, 0xD0, 0x5F, 0x6D, 0x48, 0x2E, 0x9F, 0x09, 0x54, 0x20, 0x93, 0xC2, 0x7C, 0x4D, 0x81 },
  { 0xA5, 0x5C, 0x7F, 0xE1, 0xD0, 0xBD, 0xD4, 0x37, 0x35, 0x83, 0x40, 0x1F, 0x03, 0xB6, 0xB6, 0x43 },
  { 0xAE, 0xEE, 0x7C, 0x81, 0xC0, 0x9E, 0x6C, 0x79, 0xD7, 0xDE, 0xB3, 0x1B, 0x3B, 0x26, 0xC7, 0xBA },
  { 0x63, 0x7E, 0x82, 0xB7, 0xA0, 0xFE, 0x88, 0x09, 0x91, 0xBD, 0x00, 0x38, 0x00, 0x6B, 0x87, 0xCF },
  { 0x4B, 0x8D, 0x24, 0xF0, 0xC8, 0xBD, 0xA7, 0xAC, 0xF3, 0x30, 0x9E, 0x73, 0xC2, 0x69, 0xC4, 0xE0 },
  { 0xB6, 0x3E, 0x36, 0x67, 0x47, 0xE0, 0xE8, 0xFA, 0xE5, 0xC8, 0xC1, 0xF0, 0x47, 0xCD, 0x8C, 0x82 },
  { 0x15, 0x1D, 0xBD, 0x3D, 0x7B, 0x2D, 0x09, 0x05, 0xE3, 0xC6, 0x6F, 0x21, 0xFB, 0x60, 0x68, 0x44 },
  { 0x02, 0x91, 0xF3, 0xEB, 0x08, 0x17, 0x4C, 0x8F, 0x36, 0x2F, 0x9D, 0x51, 0x37, 0x54, 0x7C, 0xC6 },
  { 0x54, 0xD4, 0xA0, 0x89, 0x82, 0xA2, 0x01, 0x92, 0x50, 0x1E, 0x1B, 0xEA, 0xDC, 0xBE, 0x71, 0x17 },
  { 0xD7, 0xFA, 0x47, 0x90, 0x8C, 0x6D, 0x13, 0x88, 0x6B, 0x28, 0x88, 0xA4, 0x2C, 0x35, 0xE9, 0x7F },
};
void print_time(unsigned long t_milli, unsigned long sz) //converting ms to time format
{
  char buffer[20];
  int days, hours, mins, secs;
  int fractime;
  unsigned long inttime;
  inttime  = t_milli / 1000; //taking milli sec
  fractime = t_milli % 1000;
  days     = inttime / (24 * 3600); //taking out days
  inttime  = inttime % (24 * 3600);
  hours    = inttime / 3600; //taking hour
  inttime  = inttime % 3600;
  mins     = inttime / 60; //taking mins
  inttime  = inttime % 60;
  secs = inttime; //taking mins
  Serial.printf("File Size in bytes:%d ", sz);
  Serial.printf("Elapsed Time:%02d:%02d:%02d.%03d\n", hours, mins, secs, fractime);
}
int test_vectors(long sz)
{
  uint8_t m[64];
  uint8_t tag[16];
  uint32_t k[4] = { 0x833D3433, 0x009F389F, 0x2398E64F, 0x417ACF39 }; //default key as per the vectors created
  uint32_t k1[4], k2[4]; //subkeys
  int i;
  int ok = 1;
  uint32_t taglen = 16;

  /* key schedule */
  subkeys(k1, k2, k);//getting keys
#if DEBUG
  Serial.printf("K0 %08X %08X %08X %08X\n", k[0], k[1], k[2], k[3]);
  Serial.printf("K1 %08X %08X %08X %08X\n", k1[0], k1[1], k1[2], k1[3]);
  Serial.printf("K2 %08X %08X %08X %08X\n", k2[0], k2[1], k2[2], k2[3]);
#endif
  Serial.println("Creating tag");
  msec = 0;     //resetting timer befor starting the chaskey implementation
  /* mac */
  for (int kl = 0; kl < (sz / 64); kl++) //dividing the size of the file to chunks
  {
    for (i = 0; i < 64; i++) // loop for 64bytes
    {
      m[i] = i ; //filling the data the
      //void chaskey(uint8_t *tag, uint32_t taglen, const uint8_t *m, const uint32_t mlen, const uint32_t k[4], const uint32_t k1[4], const uint32_t k2[4]) {
      chaskey(tag, taglen, m, i, k, k1, k2); //generating tag for each byte..
      if (memcmp( tag, vectors[i], taglen )) {    //checking the generated tag is valid
        Serial.printf("test vector failed for %d-byte message\n", i);
        ok = 0;
      }
    }
    delay(0);
  }
  if (ok == 1)
  {
    long mtime = msec; // getting the Elapsed
    Serial.println("test vectors ok\n");
    print_time(mtime, sz); // converting time format with given ms
  }
}
void timer0_ISR (void) //interrupt routine for timer
{
  msec++; //updating for every milli sec(ms)
  timer0_write(ESP.getCycleCount() + 80000); //interrupt cycles to generate for 1ms
}
void setup()
{
  Serial.begin(9600);   //initializing serail wirh baudrate 9600
  noInterrupts();       // disabling interrupt befor any starting the timer
  timer0_isr_init();    // Enabling internal timer0
  timer0_attachInterrupt(timer0_ISR);     //enabling ISR(Interrupt Service Routine) for timer0
  timer0_write(ESP.getCycleCount() + 80000);    //80Mhz -> 80*10^6 = 80000000 = 1 second //so for 1milli sec 80000
  interrupts();   //enable interrupt
  Serial.println("---------Chaskey---------");
  Serial.println("Enter File Size in Bytes:");
}

void loop()
{
  while (Serial.available())   // wait for serial input
  {
    char inChar = (char)Serial.read();   // reading data from serial
    if (inChar == '\n')str_end = true;   //checking for end
    else if ((inChar != '\r' || inChar != '\n') && str_end == false)inStr += inChar;  //adding receive data to inStr till the end
  }
  if (str_end)
  {
    unsigned long inbyt = inStr.toInt();  // Converting received string to int
    if (inbyt > 10000000)Serial.println("enter the file size within 10000000byte(10mb)");
    test_vectors(inbyt);//testing vector
    str_end = 0;//making re-entering for another file
    inStr = "";//clearing previously entered value
  }
}
